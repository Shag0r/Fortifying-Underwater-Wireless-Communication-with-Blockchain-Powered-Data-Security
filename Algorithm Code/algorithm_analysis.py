# -*- coding: utf-8 -*-
"""algorithm analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PTAJaWz_cyy6MGGasnZE3YkYnROBc0ib
"""

import random

# Constants
NUM_LEAF_NODES = 100
NUM_CENTRAL_NODES = 10
NUM_MAIN_NODES = 2  # Adjusted for the number of available central nodes
ROUND_COUNT = 10  # Number of rounds for LEACH

# Function to calculate distance between two nodes
def distance(node1, node2):
    return ((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)**0.5

# Function to elect cluster heads among central nodes using LEACH
def elect_cluster_heads(central_nodes, round_num):
    cluster_heads = []
    for node in central_nodes:
        if random.random() < calculate_probability(node, round_num):
            cluster_heads.append(node)
    return cluster_heads

# Function to calculate the probability of a node becoming a cluster head
def calculate_probability(node, round_num):
    p = NUM_MAIN_NODES / NUM_CENTRAL_NODES
    if p == 0:
        return 0
    return p * random.uniform(0, 1)  # Random value between 0 and p

# Function to assign leaf nodes to clusters, ensuring each central node receives data
def form_clusters(leaf_nodes, cluster_heads):
    clusters = {head: [] for head in cluster_heads}
    total_distance = 0
    for leaf in leaf_nodes:
        closest_head = min(cluster_heads, key=lambda head: distance(leaf, head))
        clusters[closest_head].append(leaf)
        total_distance += distance(leaf, closest_head)
    return clusters, total_distance / len(leaf_nodes)  # Return clusters and average distance

# Function to simulate data transmission from leaf nodes to central nodes
def transmit_data(leaf_clusters):
    total_energy_consumption = 0
    for head, leaf_nodes in leaf_clusters.items():
        total_distance = sum(distance(leaf, head) for leaf in leaf_nodes)
        total_energy_consumption += total_distance * len(leaf_nodes)  # Energy consumed is proportional to distance
    return total_energy_consumption

# Function to simulate data aggregation and transmission from central nodes to main nodes
def transmit_aggregated_data(cluster_heads):
    total_energy_consumption = 0
    for head in cluster_heads:
        # Assuming aggregation and transmission consume a fixed amount of energy per cluster head
        total_energy_consumption += 10  # Placeholder value
    return total_energy_consumption

# Simulation
leaf_nodes = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_LEAF_NODES)]
central_nodes = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_CENTRAL_NODES)]
prev_cluster_heads = []  # Track previous round's cluster heads

total_energy_consumption = 0
total_average_distance = 0

for round_num in range(ROUND_COUNT):
    # Elect cluster heads
    cluster_heads = elect_cluster_heads(central_nodes, round_num)
    prev_cluster_heads = cluster_heads

    # Check if there are cluster heads for the current round
    if not cluster_heads:
        print(f"No cluster heads elected for round {round_num}. Skipping round.")
        continue

    # Form clusters, ensuring each central node receives data
    leaf_clusters, round_average_distance = form_clusters(leaf_nodes, cluster_heads)
    total_average_distance += round_average_distance

    # Transmit data from leaf nodes to central nodes, calculating and printing total distance traveled
    round_energy_consumption = transmit_data(leaf_clusters)
    total_energy_consumption += round_energy_consumption

    # Transmit aggregated data from central nodes to main nodes
    round_energy_consumption += transmit_aggregated_data(cluster_heads)
    total_energy_consumption += round_energy_consumption

# Calculate average distance and total energy consumption over all rounds
average_distance = total_average_distance / ROUND_COUNT
print(f"Average Distance Traveled: {average_distance:.2f}")
print(f"Total Energy Consumption: {total_energy_consumption:.2f}")

import random
import matplotlib.pyplot as plt

# Constants
NUM_LEAF_NODES = 100
NUM_CENTRAL_NODES = 10
NUM_MAIN_NODES = 2  # Adjusted for the number of available central nodes
ROUND_COUNT = 10  # Number of rounds for LEACH
INITIAL_ENERGY_LEVEL = 100  # Initial energy level of nodes
TRANSMISSION_POWER = 0.5

# Define the set of all nodes (central nodes and leaf nodes)
NODES = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_LEAF_NODES + NUM_CENTRAL_NODES)]

# Define the set of central nodes
CENTRAL_NODES = NODES[:NUM_CENTRAL_NODES]

# Define the set of leaf nodes
LEAF_NODES = NODES[NUM_CENTRAL_NODES:]

# Define the set of main nodes (assumed to be known)
MAIN_NODES = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_MAIN_NODES)]

# Function to calculate distance between two nodes
def distance(node1, node2):
    return ((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)**0.5

# Function to elect cluster heads among central nodes using LEACH with improved energy consumption
def elect_cluster_heads(central_nodes, round_num, node_energy_levels):
    cluster_heads = []
    for node in central_nodes:
        if random.random() < calculate_probability(node, round_num, node_energy_levels):
            cluster_heads.append(node)
    return cluster_heads

# Function to calculate the probability of a node becoming a cluster head with improved energy consumption
def calculate_probability(node, round_num, node_energy_levels):
    p = (NUM_MAIN_NODES / NUM_CENTRAL_NODES) * (node_energy_levels[node] / max(node_energy_levels.values()))
    return p

# Function to assign leaf nodes to clusters, ensuring each central node receives data
def form_clusters(leaf_nodes, cluster_heads):
    clusters = {head: [] for head in cluster_heads}
    total_distance = 0
    for leaf in leaf_nodes:
        closest_head = min(cluster_heads, key=lambda head: distance(leaf, head))
        clusters[closest_head].append(leaf)
        total_distance += distance(leaf, closest_head)
    return clusters, total_distance / len(leaf_nodes)  # Return clusters and average distance

# Function to simulate data transmission from leaf nodes to central nodes with improved energy consumption
def transmit_data(leaf_clusters, node_energy_levels):
    total_energy_consumption = 0
    for head, leaf_nodes in leaf_clusters.items():
        for leaf in leaf_nodes:
            total_distance = distance(leaf, head)
            energy_consumption = total_distance * TRANSMISSION_POWER
            total_energy_consumption += energy_consumption
            node_energy_levels[leaf] -= energy_consumption  # Reduce energy level of transmitting node
            node_energy_levels[head] -= energy_consumption  # Reduce energy level of receiving node
    return total_energy_consumption

# Function to simulate data aggregation and transmission from central nodes to main nodes with improved energy consumption
def transmit_aggregated_data(cluster_heads, node_energy_levels):
    total_energy_consumption = 0
    for head in cluster_heads:
        for main_node in MAIN_NODES:
            main_node_tuple = tuple(main_node)  # Convert main_node to a tuple
            total_distance = distance(head, main_node)
            energy_consumption = total_distance * TRANSMISSION_POWER
            total_energy_consumption += energy_consumption
            node_energy_levels[head] -= energy_consumption  # Reduce energy level of transmitting node

    return total_energy_consumption


# Main simulation loop with improved energy consumption
node_energy_levels = {node: INITIAL_ENERGY_LEVEL for node in NODES}
energy_consumptions = []

for round_num in range(ROUND_COUNT):
    # Elect cluster heads
    cluster_heads = elect_cluster_heads(CENTRAL_NODES, round_num, node_energy_levels)

    # Check if there are cluster heads for the current round
    if not cluster_heads:
        print(f"No cluster heads elected for round {round_num}. Skipping round.")
        energy_consumptions.append(None)  # Append None for skipped round
        continue

    # Form clusters, ensuring each central node receives data
    leaf_clusters, _ = form_clusters(LEAF_NODES, cluster_heads)

    # Transmit data from leaf nodes to central nodes
    round_energy_consumption = transmit_data(leaf_clusters, node_energy_levels)

    # Transmit aggregated data from central nodes to main nodes
    round_energy_consumption += transmit_aggregated_data(cluster_heads, node_energy_levels)
    energy_consumptions.append(round_energy_consumption)

# Calculate total energy consumption
total_energy_consumption = sum(energy for energy in energy_consumptions if energy is not None)

# Display total energy consumption
print(f"Total energy consumption: {total_energy_consumption:.2f} units")

# Print energy consumptions for each round
for round_num, energy in enumerate(energy_consumptions, start=1):
    if energy is not None:
        print(f"Round {round_num}: {energy:.2f} units of energy consumed")
    else:
        print(f"Round {round_num}: No cluster heads elected, skipping round")
# Calculate total energy consumption
total_energy_consumption = sum(energy for energy in energy_consumptions if energy is not None)

# Display total energy consumption
print(f"Total energy consumption: {total_energy_consumption:.2f} units")


# Plotting energy consumption over rounds
plt.plot(range(1, len(energy_consumptions) + 1), energy_consumptions, marker='o', color='b')
plt.title('Energy Consumption over Rounds (Improved)')
plt.xlabel('Round')
plt.ylabel('Energy Consumption')
plt.show()

import random
import matplotlib.pyplot as plt

# Constants
NUM_LEAF_NODES = 100
NUM_CENTRAL_NODES = 10
NUM_MAIN_NODES = 2  # Adjusted for the number of available central nodes
ROUND_COUNT = 10  # Number of rounds for LEACH
INITIAL_ENERGY_LEVEL = 100  # Initial energy level of nodes
TRANSMISSION_POWER = 0.5

# Define the set of all nodes (central nodes and leaf nodes)
NODES = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_LEAF_NODES + NUM_CENTRAL_NODES)]

# Define the set of central nodes
CENTRAL_NODES = NODES[:NUM_CENTRAL_NODES]

# Define the set of leaf nodes
LEAF_NODES = NODES[NUM_CENTRAL_NODES:]

# Define the set of main nodes (assumed to be known)
MAIN_NODES = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_MAIN_NODES)]

# Function to calculate distance between two nodes
def distance(node1, node2):
    return ((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)**0.5

# Function to elect cluster heads among central nodes using LEACH with improved energy consumption
def elect_cluster_heads(central_nodes, round_num, node_energy_levels):
    cluster_heads = []
    for node in central_nodes:
        if random.random() < calculate_probability(node, round_num, node_energy_levels):
            cluster_heads.append(node)
    return cluster_heads

# Function to calculate the probability of a node becoming a cluster head with improved energy consumption
def calculate_probability(node, round_num, node_energy_levels):
    p = (NUM_MAIN_NODES / NUM_CENTRAL_NODES) * (node_energy_levels[node] / max(node_energy_levels.values()))
    return p

# Function to assign leaf nodes to clusters, ensuring each central node receives data
def form_clusters(leaf_nodes, cluster_heads):
    clusters = {head: [] for head in cluster_heads}
    total_distance = 0
    for leaf in leaf_nodes:
        closest_head = min(cluster_heads, key=lambda head: distance(leaf, head))
        clusters[closest_head].append(leaf)
        total_distance += distance(leaf, closest_head)
    return clusters, total_distance / len(leaf_nodes)  # Return clusters and average distance

# Function to simulate data transmission from leaf nodes to central nodes with improved energy consumption
def transmit_data(leaf_clusters, node_energy_levels):
    total_energy_consumption = 0
    for head, leaf_nodes in leaf_clusters.items():
        for leaf in leaf_nodes:
            total_distance = distance(leaf, head)
            energy_consumption = total_distance * TRANSMISSION_POWER
            total_energy_consumption += energy_consumption
            node_energy_levels[leaf] -= energy_consumption  # Reduce energy level of transmitting node
            node_energy_levels[head] -= energy_consumption  # Reduce energy level of receiving node
    return total_energy_consumption

# Function to simulate data aggregation and transmission from central nodes to main nodes with improved energy consumption
def transmit_aggregated_data(cluster_heads, node_energy_levels):
    total_energy_consumption = 0
    for head in cluster_heads:
        for main_node in MAIN_NODES:
            main_node_tuple = tuple(main_node)  # Convert main_node to a tuple
            total_distance = distance(head, main_node)
            energy_consumption = total_distance * TRANSMISSION_POWER
            total_energy_consumption += energy_consumption
            node_energy_levels[head] -= energy_consumption  # Reduce energy level of transmitting node

    return total_energy_consumption


# Main simulation loop with improved energy consumption
node_energy_levels = {node: INITIAL_ENERGY_LEVEL for node in NODES}
energy_consumptions = []

for round_num in range(ROUND_COUNT):
    # Elect cluster heads
    cluster_heads = elect_cluster_heads(CENTRAL_NODES, round_num, node_energy_levels)

    # Check if there are cluster heads for the current round
    if not cluster_heads:
        print(f"No cluster heads elected for round {round_num}. Skipping round.")
        energy_consumptions.append(None)  # Append None for skipped round
        continue

    # Form clusters, ensuring each central node receives data
    leaf_clusters, _ = form_clusters(LEAF_NODES, cluster_heads)

    # Transmit data from leaf nodes to central nodes
    round_energy_consumption = transmit_data(leaf_clusters, node_energy_levels)

    # Transmit aggregated data from central nodes to main nodes
    round_energy_consumption += transmit_aggregated_data(cluster_heads, node_energy_levels)
    energy_consumptions.append(round_energy_consumption)

# Calculate total energy consumption
total_energy_consumption = sum(energy for energy in energy_consumptions if energy is not None)

# Display total energy consumption
print(f"Total energy consumption: {total_energy_consumption:.2f} units")

# Print energy consumptions for each round
for round_num, energy in enumerate(energy_consumptions, start=1):
    if energy is not None:
        print(f"Round {round_num}: {energy:.2f} units of energy consumed")
    else:
        print(f"Round {round_num}: No cluster heads elected, skipping round")
# Calculate total energy consumption
total_energy_consumption = sum(energy for energy in energy_consumptions if energy is not None)

# Display total energy consumption
print(f"Total energy consumption: {total_energy_consumption:.2f} units")


# Plotting energy consumption over rounds
plt.plot(range(1, len(energy_consumptions) + 1), energy_consumptions, marker='o', color='b')
plt.title('Energy Consumption over Rounds (Improved)')
plt.xlabel('Round')
plt.ylabel('Energy Consumption')
plt.show()

import random
import matplotlib.pyplot as plt

# Constants for both algorithms
NUM_LEAF_NODES = 100
NUM_CENTRAL_NODES = 10
NUM_MAIN_NODES = 2 # Adjusted for the number of available central nodes
ROUND_COUNT = 50  # Number of rounds for LEACH
INITIAL_ENERGY_LEVEL = 100  # Initial energy level of nodes

# Define the set of all nodes (central nodes and leaf nodes)
NODES = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_LEAF_NODES + NUM_CENTRAL_NODES)]

# Define the set of central nodes
CENTRAL_NODES = NODES[:NUM_CENTRAL_NODES]

# Define the set of leaf nodes
LEAF_NODES = NODES[NUM_CENTRAL_NODES:]

# Define the set of main nodes (assumed to be known)
MAIN_NODES = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_MAIN_NODES)]

# Function to calculate distance between two nodes
def distance(node1, node2):
    return ((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)**0.5

# Function to elect cluster heads among central nodes using LEACH with improved energy consumption
def elect_cluster_heads(central_nodes, round_num, node_energy_levels):
    cluster_heads = []
    for node in central_nodes:
        if random.random() < calculate_probability(node, round_num, node_energy_levels):
            cluster_heads.append(node)
    return cluster_heads

# Function to calculate the probability of a node becoming a cluster head with improved energy consumption
def calculate_probability(node, round_num, node_energy_levels):
    p = (NUM_MAIN_NODES / NUM_CENTRAL_NODES) * (node_energy_levels[node] / max(node_energy_levels.values()))
    return p

# Function to assign leaf nodes to clusters, ensuring each central node receives data
def form_clusters(leaf_nodes, cluster_heads):
    clusters = {head: [] for head in cluster_heads}
    total_distance = 0
    for leaf in leaf_nodes:
        closest_head = min(cluster_heads, key=lambda head: distance(leaf, head))
        clusters[closest_head].append(leaf)
        total_distance += distance(leaf, closest_head)
    return clusters, total_distance / len(leaf_nodes)  # Return clusters and average distance

# Function to simulate data transmission from leaf nodes to central nodes with improved energy consumption
def transmit_data(leaf_clusters, node_energy_levels):
    total_energy_consumption = 0
    for head, leaf_nodes in leaf_clusters.items():
        for leaf in leaf_nodes:
            total_distance = distance(leaf, head)
            energy_consumption = total_distance * TRANSMISSION_POWER
            total_energy_consumption += energy_consumption
            node_energy_levels[leaf] -= energy_consumption  # Reduce energy level of transmitting node
            node_energy_levels[head] -= energy_consumption  # Reduce energy level of receiving node
    return total_energy_consumption

# Function to simulate data aggregation and transmission from central nodes to main nodes with improved energy consumption
def transmit_aggregated_data(cluster_heads, node_energy_levels):
    total_energy_consumption = 0
    for head in cluster_heads:
        for main_node in MAIN_NODES:
            main_node_tuple = tuple(main_node)  # Convert main_node to a tuple
            total_distance = distance(head, main_node)
            energy_consumption = total_distance * TRANSMISSION_POWER
            total_energy_consumption += energy_consumption
            node_energy_levels[head] -= energy_consumption  # Reduce energy level of transmitting node

    return total_energy_consumption


# Algorithm 1: LEACH Algorithm
node_energy_levels_leach = {node: INITIAL_ENERGY_LEVEL for node in NODES}
energy_consumptions_leach = []

for round_num in range(ROUND_COUNT):
    # Elect cluster heads
    cluster_heads = elect_cluster_heads(CENTRAL_NODES, round_num, node_energy_levels_leach)

    # Check if there are cluster heads for the current round
    if not cluster_heads:
        energy_consumptions_leach.append(None)  # Append None for skipped round
        continue

    # Form clusters, ensuring each central node receives data
    leaf_clusters, _ = form_clusters(LEAF_NODES, cluster_heads)

    # Transmit data from leaf nodes to central nodes
    round_energy_consumption = transmit_data(leaf_clusters, node_energy_levels_leach)

    # Transmit aggregated data from central nodes to main nodes
    round_energy_consumption += transmit_aggregated_data(cluster_heads, node_energy_levels_leach)
    energy_consumptions_leach.append(round_energy_consumption)

# Calculate total energy consumption for LEACH Algorithm
total_energy_consumption_leach = sum(energy for energy in energy_consumptions_leach if energy is not None)

# Algorithm 2: Improved LEACH Algorithm
node_energy_levels_improved = {node: INITIAL_ENERGY_LEVEL for node in NODES}
energy_consumptions_improved = []

for round_num in range(ROUND_COUNT):
    # Elect cluster heads
    cluster_heads = elect_cluster_heads(CENTRAL_NODES, round_num, node_energy_levels_improved)

    # Check if there are cluster heads for the current round
    if not cluster_heads:
        energy_consumptions_improved.append(None)  # Append None for skipped round
        continue

    # Form clusters, ensuring each central node receives data
    leaf_clusters, _ = form_clusters(LEAF_NODES, cluster_heads)

    # Transmit data from leaf nodes to central nodes
    round_energy_consumption = transmit_data(leaf_clusters, node_energy_levels_improved)

    # Transmit aggregated data from central nodes to main nodes
    round_energy_consumption += transmit_aggregated_data(cluster_heads, node_energy_levels_improved)
    energy_consumptions_improved.append(round_energy_consumption)

# Calculate total energy consumption for Improved LEACH Algorithm
total_energy_consumption_improved = sum(energy for energy in energy_consumptions_improved if energy is not None)

# Determine which algorithm has a higher energy consumption rate
if total_energy_consumption_leach > total_energy_consumption_improved:
    higher_consumption_algorithm = "LEACH Algorithm"
    lower_consumption_algorithm = "Improved LEACH Algorithm"
else:
    higher_consumption_algorithm = "Improved LEACH Algorithm"
    lower_consumption_algorithm = "LEACH Algorithm"

# Plotting energy consumption over rounds
plt.plot(range(1, len(energy_consumptions_leach) + 1), energy_consumptions_leach, marker='o', color='g', label="LEACH Algorithm")
plt.plot(range(1, len(energy_consumptions_improved) + 1), energy_consumptions_improved, marker='o', color='r', label="Improved LEACH Algorithm")
plt.title('Energy Consumption over Rounds')
plt.xlabel('Round')
plt.ylabel('Energy Consumption')
plt.legend()
plt.show()

# Display the comparison of total energy consumption rates
print(f"Total energy consumption for {higher_consumption_algorithm}: {total_energy_consumption_leach:.2f} units (marked as red)")
print(f"Total energy consumption for {lower_consumption_algorithm}: {total_energy_consumption_improved:.2f} units (marked as green)")

import matplotlib.pyplot as plt

# Calculate total energy consumption rates for each algorithm
total_energy_consumptions = [total_energy_consumption_leach, total_energy_consumption_improved]
algorithms = ['LEACH Algorithm', 'Proposed Algorithm']

# Determine colors for each bar based on which algorithm has higher consumption
colors = ['r' if energy == max(total_energy_consumptions) else 'g' for energy in total_energy_consumptions]

# Plotting the bar chart
plt.bar(algorithms, total_energy_consumptions, color=colors)
plt.title('Total Energy Consumption Comparison')
plt.xlabel('Algorithm')
plt.ylabel('Total Energy Consumption (units)')

# Adding value labels on top of each bar
for i, value in enumerate(total_energy_consumptions):
    plt.text(i, value, f'{value:.2f}', ha='center', va='bottom')

plt.show()