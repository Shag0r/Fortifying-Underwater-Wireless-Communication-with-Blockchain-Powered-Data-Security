# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iycyJiQHtpMHrDEALwGhtL95_asD7Ndo
"""

import random
import matplotlib.pyplot as plt

# Constants
NUM_LEAF_NODES = 10
NUM_CENTRAL_NODES = 2
NUM_MAIN_NODES = 2  # Adjusted for the number of available central nodes

# Function to elect cluster heads among central nodes
def elect_cluster_heads(central_nodes):
    if NUM_MAIN_NODES > len(central_nodes):
        raise ValueError("Number of cluster heads cannot exceed the number of central nodes")
    cluster_heads = random.sample(central_nodes, NUM_MAIN_NODES)
    return cluster_heads

# Function to assign leaf nodes to clusters, ensuring each central node receives data
def form_clusters(leaf_nodes, cluster_heads):
    clusters = {head: [] for head in cluster_heads}
    assigned_leaf_nodes = set()

    # Assign the first half of leaf nodes to the first cluster head
    for i, leaf in enumerate(leaf_nodes):
        if i < len(leaf_nodes) // 2:
            head = cluster_heads[0]
            clusters[head].append(leaf)
            assigned_leaf_nodes.add(leaf)

    # Assign the remaining leaf nodes to the second cluster head
    for leaf in leaf_nodes:
        if leaf not in assigned_leaf_nodes:
            head = cluster_heads[1]
            clusters[head].append(leaf)
            assigned_leaf_nodes.add(leaf)

    return clusters

# Function to simulate data transmission from leaf nodes to central nodes
def transmit_data(leaf_clusters):
    for head, leaf_nodes in leaf_clusters.items():
        print(f"Cluster Head {head} receiving data from {len(leaf_nodes)} leaf nodes")

# Function to simulate data aggregation and transmission from central nodes to main nodes
def transmit_aggregated_data(cluster_heads):
    for head in cluster_heads:
        print(f"Cluster Head {head} transmitting aggregated data to main nodes")

# Function to visualize clusters
def visualize_clusters(leaf_clusters, cluster_heads):
    plt.figure(figsize=(10, 8))
    colors = ['red', 'blue']  # Colors for different clusters
    shapes = ['o', '^']  # Shapes for different node types (cluster heads, leaf nodes)

    for i, (head, leaf_nodes) in enumerate(leaf_clusters.items()):
        plt.scatter(head[0], head[1], color=colors[0], label='Cluster Head', marker=shapes[0])
        for leaf in leaf_nodes:
            plt.scatter(leaf[0], leaf[1], color=colors[i % len(colors)], label=f'Cluster {i+1} Leaf Node', marker=shapes[1])
            plt.plot([head[0], leaf[0]], [head[1], leaf[1]], color='black', linestyle='--')

    plt.title('Cluster Formation')
    plt.xlabel('X-axis')
    plt.ylabel('Y-axis')
    plt.legend()
    plt.grid(True)
    plt.show()

# Function to calculate distance between two nodes
def distance(node1, node2):
    # Placeholder function for calculating distance (e.g., Euclidean distance)
    return ((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)**0.5

# Simulation
leaf_nodes = [(random.uniform(0, 10), random.uniform(0, 10)) for _ in range(NUM_LEAF_NODES)]
central_nodes = [(random.uniform(0, 10), random.uniform(0, 10)) for _ in range(NUM_CENTRAL_NODES)]

# Elect cluster heads
cluster_heads = elect_cluster_heads(central_nodes)

# Form clusters, ensuring each central node receives data
leaf_clusters = form_clusters(leaf_nodes, cluster_heads)

# Visualize clusters with additional visual elements
visualize_clusters(leaf_clusters, cluster_heads)

# Transmit data from leaf nodes to central nodes
transmit_data(leaf_clusters)

# Transmit aggregated data from central nodes to main nodes
transmit_aggregated_data(cluster_heads)

import random
import matplotlib.pyplot as plt

# Constants
NUM_LEAF_NODES = 100
NUM_CENTRAL_NODES = 10
NUM_MAIN_NODES = 2  # Adjusted for the number of available central nodes

# Function to elect cluster heads among central nodes
def elect_cluster_heads(central_nodes):
    if NUM_MAIN_NODES > len(central_nodes):
        raise ValueError("Number of cluster heads cannot exceed the number of central nodes")
    cluster_heads = random.sample(central_nodes, NUM_MAIN_NODES)
    return cluster_heads

# Function to assign leaf nodes to clusters, ensuring each central node receives data
def form_clusters(leaf_nodes, cluster_heads):
    clusters = {head: [] for head in cluster_heads}
    assigned_leaf_nodes = set()

    # Assign leaf nodes to the closest cluster head
    for leaf in leaf_nodes:
        closest_head = min(cluster_heads, key=lambda head: distance(leaf, head))
        clusters[closest_head].append(leaf)
        assigned_leaf_nodes.add(leaf)

    return clusters

# Function to simulate data transmission from leaf nodes to central nodes
def transmit_data(leaf_clusters):
    for head, leaf_nodes in leaf_clusters.items():
        total_distance = sum(distance(leaf, head) for leaf in leaf_nodes)
        print(f"Cluster Head {head} receiving data from {len(leaf_nodes)} leaf nodes, total distance traveled: {total_distance:.2f}")

# Function to simulate data aggregation and transmission from central nodes to main nodes
def transmit_aggregated_data(cluster_heads):
    for head in cluster_heads:
        print(f"Cluster Head {head} transmitting aggregated data to main nodes")

# Function to visualize clusters
def visualize_clusters(leaf_clusters, cluster_heads):
    plt.figure(figsize=(10, 8))
    colors = ['red', 'blue']  # Colors for different clusters
    shapes = ['o', '^']  # Shapes for different node types (cluster heads, leaf nodes)

    for i, (head, leaf_nodes) in enumerate(leaf_clusters.items()):
        plt.scatter(head[0], head[1], color=colors[0], label='Cluster Head', marker=shapes[0])
        for leaf in leaf_nodes:
            plt.scatter(leaf[0], leaf[1], color=colors[i % len(colors)], label=f'Cluster {i+1} Leaf Node', marker=shapes[1])
            plt.plot([head[0], leaf[0]], [head[1], leaf[1]], color='black', linestyle='--')

    plt.title('Cluster Formation')
    plt.xlabel('X-axis')
    plt.ylabel('Y-axis')
    plt.legend()
    plt.grid(True)
    plt.show()

# Function to calculate distance between two nodes
def distance(node1, node2):
    # Placeholder function for calculating distance (e.g., Euclidean distance)
    return ((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)**0.5

# Simulation
leaf_nodes = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_LEAF_NODES)]
central_nodes = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_CENTRAL_NODES)]

# Elect cluster heads
cluster_heads = elect_cluster_heads(central_nodes)

# Form clusters, ensuring each central node receives data
leaf_clusters = form_clusters(leaf_nodes, cluster_heads)

# Visualize clusters with additional visual elements
visualize_clusters(leaf_clusters, cluster_heads)

# Transmit data from leaf nodes to central nodes, calculating and printing total distance traveled
transmit_data(leaf_clusters)

# Transmit aggregated data from central nodes to main nodes
transmit_aggregated_data(cluster_heads)

"""**LEACH Algorithm intial performance**"""

import random
import matplotlib.pyplot as plt

# Constants
NUM_LEAF_NODES = 100
NUM_CENTRAL_NODES = 10
NUM_MAIN_NODES = 2  # Adjusted for the number of available central nodes
ROUND_COUNT = 10  # Number of rounds for LEACH

# Function to calculate distance between two nodes
def distance(node1, node2):
    return ((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)**0.5

# Function to elect cluster heads among central nodes using LEACH
def elect_cluster_heads(central_nodes, round_num):
    cluster_heads = []
    for node in central_nodes:
        if random.random() < calculate_probability(node, round_num):
            cluster_heads.append(node)
    return cluster_heads

# Function to calculate the probability of a node becoming a cluster head
def calculate_probability(node, round_num):
    p = NUM_MAIN_NODES / NUM_CENTRAL_NODES
    # Alternative, potentially more flexible approach:
    if p == 0:
        return 0
    return p * random.uniform(0, 1)  # Random value between 0 and p




# Function to assign leaf nodes to clusters, ensuring each central node receives data
def form_clusters(leaf_nodes, cluster_heads):
    clusters = {head: [] for head in cluster_heads}
    for leaf in leaf_nodes:
        closest_head = min(cluster_heads, key=lambda head: distance(leaf, head))
        clusters[closest_head].append(leaf)
    return clusters

# Function to simulate data transmission from leaf nodes to central nodes
def transmit_data(leaf_clusters):
    for head, leaf_nodes in leaf_clusters.items():
        total_distance = sum(distance(leaf, head) for leaf in leaf_nodes)
        print(f"Cluster Head {head} receiving data from {len(leaf_nodes)} leaf nodes, total distance traveled: {total_distance:.2f}")

# Function to simulate data aggregation and transmission from central nodes to main nodes
def transmit_aggregated_data(cluster_heads):
    for head in cluster_heads:
        print(f"Cluster Head {head} transmitting aggregated data to main nodes")

# Function to visualize clusters
def visualize_clusters(leaf_clusters, cluster_heads):
    plt.figure(figsize=(10, 8))
    colors = ['red', 'blue']  # Colors for different clusters
    shapes = ['o', '^']  # Shapes for different node types (cluster heads, leaf nodes)

    for i, (head, leaf_nodes) in enumerate(leaf_clusters.items()):
        plt.scatter(head[0], head[1], color=colors[0], label='Cluster Head', marker=shapes[0])
        for leaf in leaf_nodes:
            plt.scatter(leaf[0], leaf[1], color=colors[i % len(colors)], label=f'Cluster {i+1} Leaf Node', marker=shapes[1])
            plt.plot([head[0], leaf[0]], [head[1], leaf[1]], color='black', linestyle='--')

    plt.title('Cluster Formation')
    plt.xlabel('X-axis')
    plt.ylabel('Y-axis')
    plt.legend()
    plt.grid(True)
    plt.show()

# Simulation
leaf_nodes = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_LEAF_NODES)]
central_nodes = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_CENTRAL_NODES)]
prev_cluster_heads = []  # Track previous round's cluster heads

for round_num in range(ROUND_COUNT):
    # Elect cluster heads
    cluster_heads = elect_cluster_heads(central_nodes, round_num)
    prev_cluster_heads = cluster_heads

    # Check if there are cluster heads for the current round
    if not cluster_heads:
        print(f"No cluster heads elected for round {round_num}. Skipping round.")
        continue

    # Form clusters, ensuring each central node receives data
    leaf_clusters = form_clusters(leaf_nodes, cluster_heads)

    # Visualize clusters with additional visual elements
    visualize_clusters(leaf_clusters, cluster_heads)

    # Transmit data from leaf nodes to central nodes, calculating and printing total distance traveled
    transmit_data(leaf_clusters)

    # Transmit aggregated data from central nodes to main nodes
    transmit_aggregated_data(cluster_heads)

"""*Performance measure of the algorithm *
-> Energy , distance and network

"""

import random
import matplotlib.pyplot as plt

# Constants
NUM_LEAF_NODES = 100
NUM_CENTRAL_NODES = 10
NUM_MAIN_NODES = 2  # Adjusted for the number of available central nodes
ROUND_COUNT = 10  # Number of rounds for LEACH

# Function to calculate distance between two nodes
def distance(node1, node2):
    return ((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)**0.5

# Function to elect cluster heads among central nodes using LEACH
def elect_cluster_heads(central_nodes, round_num):
    cluster_heads = []
    for node in central_nodes:
        if random.random() < calculate_probability(node, round_num):
            cluster_heads.append(node)
    return cluster_heads

# Function to calculate the probability of a node becoming a cluster head
def calculate_probability(node, round_num):
    p = NUM_MAIN_NODES / NUM_CENTRAL_NODES
    if p == 0:
        return 0
    return p * random.uniform(0, 1)  # Random value between 0 and p

# Function to assign leaf nodes to clusters, ensuring each central node receives data
def form_clusters(leaf_nodes, cluster_heads):
    clusters = {head: [] for head in cluster_heads}
    total_distance = 0
    for leaf in leaf_nodes:
        closest_head = min(cluster_heads, key=lambda head: distance(leaf, head))
        clusters[closest_head].append(leaf)
        total_distance += distance(leaf, closest_head)
    return clusters, total_distance / len(leaf_nodes)  # Return clusters and average distance

# Function to simulate data transmission from leaf nodes to central nodes
def transmit_data(leaf_clusters):
    total_energy_consumption = 0
    for head, leaf_nodes in leaf_clusters.items():
        total_distance = sum(distance(leaf, head) for leaf in leaf_nodes)
        total_energy_consumption += total_distance * len(leaf_nodes)  # Energy consumed is proportional to distance
        print(f"Cluster Head {head} receiving data from {len(leaf_nodes)} leaf nodes, total distance traveled: {total_distance:.2f}")
    return total_energy_consumption

# Function to simulate data aggregation and transmission from central nodes to main nodes
def transmit_aggregated_data(cluster_heads):
    total_energy_consumption = 0
    for head in cluster_heads:
        # Assuming aggregation and transmission consume a fixed amount of energy per cluster head
        total_energy_consumption += 10  # Placeholder value
        print(f"Cluster Head {head} transmitting aggregated data to main nodes")
    return total_energy_consumption

# Function to visualize clusters
def visualize_clusters(leaf_clusters, cluster_heads):
    plt.figure(figsize=(10, 8))
    colors = ['red', 'blue']  # Colors for different clusters
    shapes = ['o', '^']  # Shapes for different node types (cluster heads, leaf nodes)

    for i, (head, leaf_nodes) in enumerate(leaf_clusters.items()):
        plt.scatter(head[0], head[1], color=colors[0], label='Cluster Head', marker=shapes[0])
        for leaf in leaf_nodes:
            plt.scatter(leaf[0], leaf[1], color=colors[i % len(colors)], label=f'Cluster {i+1} Leaf Node', marker=shapes[1])
            plt.plot([head[0], leaf[0]], [head[1], leaf[1]], color='black', linestyle='--')

    plt.title('Cluster Formation')
    plt.xlabel('X-axis')
    plt.ylabel('Y-axis')
    plt.legend()
    plt.grid(True)
    plt.show()

# Simulation
leaf_nodes = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_LEAF_NODES)]
central_nodes = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_CENTRAL_NODES)]
prev_cluster_heads = []  # Track previous round's cluster heads

total_energy_consumption = 0
total_average_distance = 0

for round_num in range(ROUND_COUNT):
    # Elect cluster heads
    cluster_heads = elect_cluster_heads(central_nodes, round_num)
    prev_cluster_heads = cluster_heads

    # Check if there are cluster heads for the current round
    if not cluster_heads:
        print(f"No cluster heads elected for round {round_num}. Skipping round.")
        continue

    # Form clusters, ensuring each central node receives data
    leaf_clusters, round_average_distance = form_clusters(leaf_nodes, cluster_heads)
    total_average_distance += round_average_distance

    # Visualize clusters with additional visual elements
    visualize_clusters(leaf_clusters, cluster_heads)

    # Transmit data from leaf nodes to central nodes, calculating and printing total distance traveled
    round_energy_consumption = transmit_data(leaf_clusters)
    total_energy_consumption += round_energy_consumption

    # Transmit aggregated data from central nodes to main nodes
    round_energy_consumption += transmit_aggregated_data(cluster_heads)
    total_energy_consumption += round_energy_consumption

# Calculate average distance and total energy consumption over all rounds
average_distance = total_average_distance / ROUND_COUNT
print(f"Average Distance Traveled: {average_distance:.2f}")
print(f"Total Energy Consumption: {total_energy_consumption:.2f}")

import random
import matplotlib.pyplot as plt

# Constants
NUM_LEAF_NODES = 100
NUM_CENTRAL_NODES = 10
NUM_MAIN_NODES = 2  # Adjusted for the number of available central nodes
ROUND_COUNT = 10  # Number of rounds for LEACH

# Function to calculate distance between two nodes
def distance(node1, node2):
    return ((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)**0.5

# Function to elect cluster heads among central nodes using LEACH
def elect_cluster_heads(central_nodes, round_num):
    cluster_heads = []
    for node in central_nodes:
        if random.random() < calculate_probability(node, round_num):
            cluster_heads.append(node)
    return cluster_heads

# Function to calculate the probability of a node becoming a cluster head
def calculate_probability(node, round_num):
    p = NUM_MAIN_NODES / NUM_CENTRAL_NODES
    if p == 0:
        return 0
    return p * random.uniform(0, 1)  # Random value between 0 and p

# Function to assign leaf nodes to clusters, ensuring each central node receives data
def form_clusters(leaf_nodes, cluster_heads):
    clusters = {head: [] for head in cluster_heads}
    total_distance = 0
    for leaf in leaf_nodes:
        closest_head = min(cluster_heads, key=lambda head: distance(leaf, head))
        clusters[closest_head].append(leaf)
        total_distance += distance(leaf, closest_head)
    return clusters, total_distance / len(leaf_nodes)  # Return clusters and average distance

# Function to simulate data transmission from leaf nodes to central nodes
def transmit_data(leaf_clusters):
    total_energy_consumption = 0
    for head, leaf_nodes in leaf_clusters.items():
        total_distance = sum(distance(leaf, head) for leaf in leaf_nodes)
        total_energy_consumption += total_distance * len(leaf_nodes)  # Energy consumed is proportional to distance
    return total_energy_consumption

# Function to simulate data aggregation and transmission from central nodes to main nodes
def transmit_aggregated_data(cluster_heads):
    total_energy_consumption = 0
    for head in cluster_heads:
        # Assuming aggregation and transmission consume a fixed amount of energy per cluster head
        total_energy_consumption += 10  # Placeholder value
    return total_energy_consumption

# Simulation
leaf_nodes = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_LEAF_NODES)]
central_nodes = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_CENTRAL_NODES)]
prev_cluster_heads = []  # Track previous round's cluster heads

# Track energy consumption and distance over rounds
energy_consumptions = []
average_distances = []

for round_num in range(ROUND_COUNT):
    # Elect cluster heads
    cluster_heads = elect_cluster_heads(central_nodes, round_num)
    prev_cluster_heads = cluster_heads

    # Check if there are cluster heads for the current round
    if not cluster_heads:
        print(f"No cluster heads elected for round {round_num}. Skipping round.")
        energy_consumptions.append(None)  # Append None for skipped round
        average_distances.append(None)  # Append None for skipped round
        continue

    # Form clusters, ensuring each central node receives data
    leaf_clusters, round_average_distance = form_clusters(leaf_nodes, cluster_heads)
    average_distances.append(round_average_distance)

    # Transmit data from leaf nodes to central nodes, calculating and printing total distance traveled
    round_energy_consumption = transmit_data(leaf_clusters)

    # Transmit aggregated data from central nodes to main nodes
    round_energy_consumption += transmit_aggregated_data(cluster_heads)
    energy_consumptions.append(round_energy_consumption)

# Plotting energy consumption and distance traveled over rounds
plt.figure(figsize=(10, 5))

# Plot energy consumption
plt.subplot(1, 2, 1)
plt.plot(range(1, len(energy_consumptions) + 1), energy_consumptions, marker='o', color='b')
plt.title('Energy Consumption over Rounds')
plt.xlabel('Round')
plt.ylabel('Energy Consumption')

# Plot average distance traveled
plt.subplot(1, 2, 2)
plt.plot(range(1, len(average_distances) + 1), average_distances, marker='o', color='r')
plt.title('Average Distance Traveled over Rounds')
plt.xlabel('Round')
plt.ylabel('Average Distance')

plt.tight_layout()
plt.show()

import random
import matplotlib.pyplot as plt

# Constants
NUM_LEAF_NODES = 100
NUM_CENTRAL_NODES = 10
NUM_MAIN_NODES = 2  # Adjusted for the number of available central nodes
ROUND_COUNT = 10  # Number of rounds for LEACH
INITIAL_ENERGY_LEVEL = 100  # Initial energy level of nodes
TRANSMISSION_POWER = 0.3

# Define the set of all nodes (central nodes and leaf nodes)
NODES = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_LEAF_NODES + NUM_CENTRAL_NODES)]

# Define the set of central nodes
CENTRAL_NODES = NODES[:NUM_CENTRAL_NODES]

# Define the set of leaf nodes
LEAF_NODES = NODES[NUM_CENTRAL_NODES:]

# Define the set of main nodes (assumed to be known)
MAIN_NODES = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_MAIN_NODES)]

# Function to calculate distance between two nodes
def distance(node1, node2):
    return ((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)**0.5

# Function to elect cluster heads among central nodes using LEACH with improved energy consumption
def elect_cluster_heads(central_nodes, round_num, node_energy_levels):
    cluster_heads = []
    for node in central_nodes:
        if random.random() < calculate_probability(node, round_num, node_energy_levels):
            cluster_heads.append(node)
    return cluster_heads

# Function to calculate the probability of a node becoming a cluster head with improved energy consumption
def calculate_probability(node, round_num, node_energy_levels):
    p = (NUM_MAIN_NODES / NUM_CENTRAL_NODES) * (node_energy_levels[node] / max(node_energy_levels.values()))
    return p

# Function to assign leaf nodes to clusters, ensuring each central node receives data
def form_clusters(leaf_nodes, cluster_heads):
    clusters = {head: [] for head in cluster_heads}
    total_distance = 0
    for leaf in leaf_nodes:
        closest_head = min(cluster_heads, key=lambda head: distance(leaf, head))
        clusters[closest_head].append(leaf)
        total_distance += distance(leaf, closest_head)
    return clusters, total_distance / len(leaf_nodes)  # Return clusters and average distance

# Function to simulate data transmission from leaf nodes to central nodes with improved energy consumption
def transmit_data(leaf_clusters, node_energy_levels):
    total_energy_consumption = 0
    for head, leaf_nodes in leaf_clusters.items():
        for leaf in leaf_nodes:
            total_distance = distance(leaf, head)
            energy_consumption = total_distance * TRANSMISSION_POWER
            total_energy_consumption += energy_consumption
            node_energy_levels[leaf] -= energy_consumption  # Reduce energy level of transmitting node
            node_energy_levels[head] -= energy_consumption  # Reduce energy level of receiving node
    return total_energy_consumption

# Function to simulate data aggregation and transmission from central nodes to main nodes with improved energy consumption
def transmit_aggregated_data(cluster_heads, node_energy_levels):
    total_energy_consumption = 0
    for head in cluster_heads:
        for main_node in MAIN_NODES:
            main_node_tuple = tuple(main_node)  # Convert main_node to a tuple
            total_distance = distance(head, main_node)
            energy_consumption = total_distance * TRANSMISSION_POWER
            total_energy_consumption += energy_consumption
            node_energy_levels[head] -= energy_consumption  # Reduce energy level of transmitting node

    return total_energy_consumption


# Main simulation loop with improved energy consumption
node_energy_levels = {node: INITIAL_ENERGY_LEVEL for node in NODES}
energy_consumptions = []

for round_num in range(ROUND_COUNT):
    # Elect cluster heads
    cluster_heads = elect_cluster_heads(CENTRAL_NODES, round_num, node_energy_levels)

    # Check if there are cluster heads for the current round
    if not cluster_heads:
        print(f"No cluster heads elected for round {round_num}. Skipping round.")
        energy_consumptions.append(None)  # Append None for skipped round
        continue

    # Form clusters, ensuring each central node receives data
    leaf_clusters, _ = form_clusters(LEAF_NODES, cluster_heads)

    # Transmit data from leaf nodes to central nodes
    round_energy_consumption = transmit_data(leaf_clusters, node_energy_levels)

    # Transmit aggregated data from central nodes to main nodes
    round_energy_consumption += transmit_aggregated_data(cluster_heads, node_energy_levels)
    energy_consumptions.append(round_energy_consumption)

# Calculate total energy consumption
total_energy_consumption = sum(energy for energy in energy_consumptions if energy is not None)

# Display total energy consumption
print(f"Total energy consumption: {total_energy_consumption:.2f} units")

# Print energy consumptions for each round
for round_num, energy in enumerate(energy_consumptions, start=1):
    if energy is not None:
        print(f"Round {round_num}: {energy:.2f} units of energy consumed")
    else:
        print(f"Round {round_num}: No cluster heads elected, skipping round")
# Calculate total energy consumption
total_energy_consumption = sum(energy for energy in energy_consumptions if energy is not None)

# Display total energy consumption
print(f"Total energy consumption: {total_energy_consumption:.2f} units")


# Plotting energy consumption over rounds
plt.plot(range(1, len(energy_consumptions) + 1), energy_consumptions, marker='o', color='b')
plt.title('Energy Consumption over Rounds (Improved)')
plt.xlabel('Round')
plt.ylabel('Energy Consumption')
plt.show()

import random
import matplotlib.pyplot as plt

# Constants for both algorithms
NUM_LEAF_NODES = 100
NUM_CENTRAL_NODES = 10
NUM_MAIN_NODES = 2 # Adjusted for the number of available central nodes
ROUND_COUNT = 50  # Number of rounds for LEACH
INITIAL_ENERGY_LEVEL = 100  # Initial energy level of nodes

# Define the set of all nodes (central nodes and leaf nodes)
NODES = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_LEAF_NODES + NUM_CENTRAL_NODES)]

# Define the set of central nodes
CENTRAL_NODES = NODES[:NUM_CENTRAL_NODES]

# Define the set of leaf nodes
LEAF_NODES = NODES[NUM_CENTRAL_NODES:]

# Define the set of main nodes (assumed to be known)
MAIN_NODES = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(NUM_MAIN_NODES)]

# Function to calculate distance between two nodes
def distance(node1, node2):
    return ((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)**0.5

# Function to elect cluster heads among central nodes using LEACH with improved energy consumption
def elect_cluster_heads(central_nodes, round_num, node_energy_levels):
    cluster_heads = []
    for node in central_nodes:
        if random.random() < calculate_probability(node, round_num, node_energy_levels):
            cluster_heads.append(node)
    return cluster_heads

# Function to calculate the probability of a node becoming a cluster head with improved energy consumption
def calculate_probability(node, round_num, node_energy_levels):
    p = (NUM_MAIN_NODES / NUM_CENTRAL_NODES) * (node_energy_levels[node] / max(node_energy_levels.values()))
    return p

# Function to assign leaf nodes to clusters, ensuring each central node receives data
def form_clusters(leaf_nodes, cluster_heads):
    clusters = {head: [] for head in cluster_heads}
    total_distance = 0
    for leaf in leaf_nodes:
        closest_head = min(cluster_heads, key=lambda head: distance(leaf, head))
        clusters[closest_head].append(leaf)
        total_distance += distance(leaf, closest_head)
    return clusters, total_distance / len(leaf_nodes)  # Return clusters and average distance

# Function to simulate data transmission from leaf nodes to central nodes with improved energy consumption
def transmit_data(leaf_clusters, node_energy_levels):
    total_energy_consumption = 0
    for head, leaf_nodes in leaf_clusters.items():
        for leaf in leaf_nodes:
            total_distance = distance(leaf, head)
            energy_consumption = total_distance * TRANSMISSION_POWER
            total_energy_consumption += energy_consumption
            node_energy_levels[leaf] -= energy_consumption  # Reduce energy level of transmitting node
            node_energy_levels[head] -= energy_consumption  # Reduce energy level of receiving node
    return total_energy_consumption

# Function to simulate data aggregation and transmission from central nodes to main nodes with improved energy consumption
def transmit_aggregated_data(cluster_heads, node_energy_levels):
    total_energy_consumption = 0
    for head in cluster_heads:
        for main_node in MAIN_NODES:
            main_node_tuple = tuple(main_node)  # Convert main_node to a tuple
            total_distance = distance(head, main_node)
            energy_consumption = total_distance * TRANSMISSION_POWER
            total_energy_consumption += energy_consumption
            node_energy_levels[head] -= energy_consumption  # Reduce energy level of transmitting node

    return total_energy_consumption


# Algorithm 1: LEACH Algorithm
node_energy_levels_leach = {node: INITIAL_ENERGY_LEVEL for node in NODES}
energy_consumptions_leach = []

for round_num in range(ROUND_COUNT):
    # Elect cluster heads
    cluster_heads = elect_cluster_heads(CENTRAL_NODES, round_num, node_energy_levels_leach)

    # Check if there are cluster heads for the current round
    if not cluster_heads:
        energy_consumptions_leach.append(None)  # Append None for skipped round
        continue

    # Form clusters, ensuring each central node receives data
    leaf_clusters, _ = form_clusters(LEAF_NODES, cluster_heads)

    # Transmit data from leaf nodes to central nodes
    round_energy_consumption = transmit_data(leaf_clusters, node_energy_levels_leach)

    # Transmit aggregated data from central nodes to main nodes
    round_energy_consumption += transmit_aggregated_data(cluster_heads, node_energy_levels_leach)
    energy_consumptions_leach.append(round_energy_consumption)

# Calculate total energy consumption for LEACH Algorithm
total_energy_consumption_leach = sum(energy for energy in energy_consumptions_leach if energy is not None)

# Algorithm 2: Improved LEACH Algorithm
node_energy_levels_improved = {node: INITIAL_ENERGY_LEVEL for node in NODES}
energy_consumptions_improved = []

for round_num in range(ROUND_COUNT):
    # Elect cluster heads
    cluster_heads = elect_cluster_heads(CENTRAL_NODES, round_num, node_energy_levels_improved)

    # Check if there are cluster heads for the current round
    if not cluster_heads:
        energy_consumptions_improved.append(None)  # Append None for skipped round
        continue

    # Form clusters, ensuring each central node receives data
    leaf_clusters, _ = form_clusters(LEAF_NODES, cluster_heads)

    # Transmit data from leaf nodes to central nodes
    round_energy_consumption = transmit_data(leaf_clusters, node_energy_levels_improved)

    # Transmit aggregated data from central nodes to main nodes
    round_energy_consumption += transmit_aggregated_data(cluster_heads, node_energy_levels_improved)
    energy_consumptions_improved.append(round_energy_consumption)

# Calculate total energy consumption for Improved LEACH Algorithm
total_energy_consumption_improved = sum(energy for energy in energy_consumptions_improved if energy is not None)

# Determine which algorithm has a higher energy consumption rate
if total_energy_consumption_leach > total_energy_consumption_improved:
    higher_consumption_algorithm = "Existing Algorithm"
    lower_consumption_algorithm = "Proposed Algorithm"
else:
    higher_consumption_algorithm = "Proposed Algorithm"
    lower_consumption_algorithm = "Existing Algorithm"

# Plotting energy consumption over rounds
plt.plot(range(1, len(energy_consumptions_leach) + 1), energy_consumptions_leach, marker='o', color='g', label="Existing Algorithm")
plt.plot(range(1, len(energy_consumptions_improved) + 1), energy_consumptions_improved, marker='o', color='r', label="Proposed Algorithm")
plt.title('Energy Consumption over Rounds')
plt.xlabel('Round')
plt.ylabel('Energy Consumption')
plt.legend()
plt.show()

# Display the comparison of total energy consumption rates
print(f"Total energy consumption for {higher_consumption_algorithm}: {total_energy_consumption_leach:.2f} units (marked as red)")
print(f"Total energy consumption for {lower_consumption_algorithm}: {total_energy_consumption_improved:.2f} units (marked as green)")

import matplotlib.pyplot as plt

# Calculate total energy consumption rates for each algorithm
total_energy_consumptions = [total_energy_consumption_leach, total_energy_consumption_improved]
algorithms = ['LEACH Algorithm', 'Proposed Algorithm']

# Determine colors for each bar based on which algorithm has higher consumption
colors = ['r' if energy == max(total_energy_consumptions) else 'g' for energy in total_energy_consumptions]

# Plotting the bar chart
plt.bar(algorithms, total_energy_consumptions, color=colors)
plt.title('Total Energy Consumption Comparison')
plt.xlabel('Algorithm')
plt.ylabel('Total Energy Consumption (units)')

# Adding value labels on top of each bar
for i, value in enumerate(total_energy_consumptions):
    plt.text(i, value, f'{value:.2f}', ha='center', va='bottom')

plt.show()